library(EchoStateNet)
library(ggplot2)
library()
devtools::install_github("matthiasadriaens/EchoStateNet")
library(EchoStateNet)
require(data.table) ## 1.9.2
?EchoStateNet
?createESN
setwd("C:/Users/matth/OneDrive/Desktop/thesis/R/data/nasa")
#Reading in C-MAPSS data
varnames <- c("Unit number","Time in cycles","Operational setting 1","Operatinal setting 2","Operational setting 3","Sensor 1","Sensor 2","Sensor 3","Sensor 4","Sensor 5","Sensor 6","Sensor 7","Sensor 8","Sensor 9","Sensor 10","Sensor 11","Sensor 12","Sensor 13","Sensor 14","Sensor 15","Sensor 16","Sensor 17","Sensor 18","Sensor 19","Sensor 20","Sensor 21")
RULnames <- c("RUL")
set1 <- list(train = read.table("train_FD001.txt",col.names = varnames),
test = read.table("test_FD001.txt",col.names = varnames),
RUL= read.table("RUL_FD001.txt",col.names = RULnames))
RUL <- cbind(1:nrow(set1[["RUL"]]), set1[["RUL"]])
names(RUL) <- c("Unit.number","RUL")
test_RUL <- merge(set1[["test"]],RUL,by="Unit.number")
set1[["test_RUL"]] <- test_RUL
#Plot sensor facet on motor
ggplot(data = set1[["test_RUL"]][set1[["test_RUL"]]$Unit.number < 5,],
aes(x = Time.in.cycles,y = Sensor.12,color = RUL)) +
geom_line() +
facet_grid(. ~ Unit.number)
#Plot different motors on one plot
m <- set1[["train"]][set1[["train"]]$Unit.number < 11,]
create_smooth_graph <- function(colname){
m$Unit.number <- as.character(m$Unit.number)
ggplot(m,
aes(x = Time.in.cycles, y = m[,(colname + 5)],colour = Unit.number)) +
geom_line(alpha = 0.5) +  geom_smooth(se= FALSE) +theme_bw() +
labs(x = "Time in cycles", y = paste("Sensor ",colname)) +
theme(legend.position="none")
}
#Calculating the remaining usefull life variable
data_train_rul <- set1[["train"]]
data_test_rul <- set1[["test"]]
data_rul <- set1[["RUL"]]
#Get RUL (=max cycles)
data_aggreg <- aggregate(data_train_rul$Time.in.cycles,by = list(data_train_rul$Unit.number), FUN = max)
names(data_aggreg) <- c("Unit.number","cycle.max")
data_aggreg_test <- aggregate(data_test_rul$Time.in.cycles,by = list(data_test_rul$Unit.number), FUN = max)
#The max cycle is this max plus the remaining life (hence that this the test set is)
data_aggreg_test <- cbind(data_aggreg_test,data_rul)
names(data_aggreg_test) <- c("Unit.number","cycle.max","RUL")
data_aggreg_test$max <- (data_aggreg_test$cycle.max + data_aggreg_test$RUL)
#clean up df
data_aggreg_test$cycle.max <- NULL
data_aggreg_test$RUL <- NULL
names(data_aggreg_test) <- c("Unit.number","cycle.max")
#Join dfs
data_train_rul_joined <- merge(data_train_rul,data_aggreg,by = "Unit.number")
data_test_rul_joined <- merge(data_test_rul,data_aggreg_test,by = "Unit.number")
data_train_rul <- data_train_rul_joined
data_test_rul <- data_test_rul_joined
#Create new var RUL which is max_cyle minus cycle_time to get rul
data_train_rul$RUL.in.cycles <- (data_train_rul$cycle.max - data_train_rul$Time.in.cycles)
data_test_rul$RUL.in.cycles <- (data_test_rul$cycle.max - data_test_rul$Time.in.cycles)
#Plot the same multi-plot but now with RUL on the x-axis
#Plot different sensors for the first ten engines on one plot
m <- data_train_rul[data_train_rul$Unit.number < 11,] #Subset for only the first ten engines
create_smooth_graph_rul <- function(colname){
m$Unit.number <- as.character(m$Unit.number)
ggplot(m,
aes(x = RUL.in.cycles, y = m[,(colname + 5)],colour = Unit.number)) +
geom_line(alpha = 0.5) +  geom_smooth(se= FALSE) +theme_bw() +
labs(x = "Time in cycles", y = paste("Sensor ",colname)) +
theme(legend.position="none") +
scale_x_continuous(trans = "reverse")
}
#MULTIPLOT FUNCTION
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
library(grid)
# Make a list from the ... arguments and plotlist
plots <- c(list(...), plotlist)
numPlots = length(plots)
# If layout is NULL, then use 'cols' to determine layout
if (is.null(layout)) {
# Make the panel
# ncol: Number of columns of plots
# nrow: Number of rows needed, calculated from # of cols
layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
ncol = cols, nrow = ceiling(numPlots/cols))
}
if (numPlots==1) {
print(plots[[1]])
} else {
# Set up the page
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
# Make each plot, in the correct location
for (i in 1:numPlots) {
# Get the i,j matrix positions of the regions that contain this subplot
matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
layout.pos.col = matchidx$col))
}
}
}
##LINEAR REGRESSION TEST
#df-train : data_train_rul
#df-test  : data_test_rul
names(data_train_rul) <- c(varnames,"MAX.cycles","RUL.in.cycles")
names(data_test_rul) <- c(varnames,"MAX.cycles","RUL.in.cycles")
linearMod <- lm(RUL.in.cycles ~ ., data=data_train_rul[,c(6:26,28)]) #Only keep sensors and RUL
print(linearMod)
data_test_rul <- as.data.table(data_test_rul)
mm <- data_test_rul[data_test_rul[, .I[`Time in cycles` == max(`Time in cycles`)], by="Unit number"]$V1]
data_test_rul_to_predict <- mm
lm_predict <- stats::predict(linearMod,data_test_rul_to_predict[,c(6:26,28)]) #Use the stats package because rESN is masking the predict funtion. Hence a null vector will be generated (without warning)
lm_predict <- as.data.frame(lm_predict)
names(lm_predict) <- c("Predict")
#test scatter
predict_df <- cbind(data_test_rul_to_predict,lm_predict)
ggplot(predict_df,aes(x = predict_df$RUL.in.cycles, y = predict_df$Predict)) +
geom_point() +
labs(title = "Multi Var Linear Regressioin",
x = "True Remaining Useful Life",
y = "Predicted Remaining Useful Life") +
geom_abline(intercept = 0, slope = 1,colour = "blue")
#Classification of the linear model
confusion_matrix <- predict_df[,c(28:29)]
confusion_matrix$Predict <- round(confusion_matrix$Predict,2) #Round the predicted values
confusion_matrix$predict_true <- ifelse(confusion_matrix$Predict <= 50,1,0)
confusion_matrix$RUL_true <- ifelse(confusion_matrix$RUL.in.cycles <= 50,1,0)
confusion_matrix$true <- ifelse(confusion_matrix$predict_true == confusion_matrix$RUL_true,1,0)
#ECHO STATE NETWORK BASED MODEL
data_train_rul[,c(22)]  <- as.numeric(data_train_rul[,c(22)])
data_train_rul[,c(23)]  <- as.numeric(data_train_rul[,c(23)])
data_train_rul[,c(27)]  <- as.numeric(data_train_rul[,c(27)])
data_train_rul[,c(28)]  <- as.numeric(data_train_rul[,c(28)])
net_train <- as.matrix(data_train_rul[c(1:100),c(6:26)])
net_u <- as.matrix(as.numeric(data_train_rul[c(1:100),c(28)]))
library(EchoStateNet) #This package is masking the stats::predict function
?createESN
net <- createESN(leaking.rate =0.2,
lambda = 0.5,
spectral.radius = 0.5,
n.neurons = 1000,
U = net_u,
Y = net_train)
net <- train(net)
#Only keep last vals of the cycle for prediction
to_pred <- data_test_rul_to_predict
ypred <- EchoStateNet::predict(net, u = as.matrix(to_pred[,c(6:26)]))
ypred <- EchoStateNet::predict(net, U = as.matrix(to_pred[,c(6:26)]))
dim(ypred)
ypred
dim(to_pred)
to_pred
net@W_in
net <- createESN(leaking.rate =0.2,
lambda = 0.5,
spectral.radius = 0.5,
n.neurons = 1000,
U = net_u,
Y = net_train)
train(net)
ypred <- EchoStateNet::predict(net, U = as.matrix(to_pred[,c(6:26)]))
dim(net@W_in)
dim(net@U)
dim(net_u)
dim(net_train)
library(EchoStateNet) #This package is masking the stats::predict function
net <- createESN(leaking.rate =0.2,
lambda = 0.5,
spectral.radius = 0.5,
n.neurons = 1000,
U = net_train,
Y = net_u)
dim(net@W_in)
train(net)
ypred <- EchoStateNet::predict(net, U = as.matrix(to_pred[,c(6:26)]))
dim(ypred)
ypred
plot(ypred)
library(EchoStateNet)
devtools::install_github("matthiasadriaens/EchoStateNet")
library(EchoStateNet)
net <- EchoStateNet::createESN(leaking.rate =0.2,
lambda = 0.5,
spectral.radius = 0.5,
n.neurons = 1000,
U = net_train,
Y = net_u)
net <- EchoStateNet::train(net)
ypred <- EchoStateNet::predict(net, U = as.matrix(to_pred[,c(6:26)]))
ypred
plot(ypred)
dim(to_pred)
dim(net_train)
